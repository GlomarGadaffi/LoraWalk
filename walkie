/*
 * @Description: Voice-over-FSK Walkie Talkie (Optimized)
 * @Hardware: ESP32-S3 + SX1262 + MSM261 (Mic) + MAX98357A (Amp)
 * @Protocol: FSK @ 19.2 kbps (High Speed/Low Latency)
 * @Codec: Codec2 (Mode 3200)
 */

#include <Arduino.h>
#include <vector>
#include "RadioLib.h"
#include "pin_config.h"             // Ensure this file exists with your pin defs
#include "Arduino_DriveBus_Library.h"
#include "codec2.h"

// --- Audio Configuration ---
#define IIS_SAMPLE_RATE 8000
#define IIS_DATA_BIT    16

// --- Radio Configuration ---
// FSK is faster than LoRa. We use 19.2 kbps to easily handle the 3.2 kbps audio stream.
#define FSK_FREQ        914.6  // MHz (US)
#define FSK_BITRATE     19.2   // kbps
#define FSK_FREQ_DEV    10.0   // kHz
#define FSK_RX_BW       39.0   // kHz
#define FSK_PWR         22     // dBm
#define FSK_PREAMBLE    16     // bits

// Packet Sizing
#define PACKET_HEADER_SIZE  12
#define PACKET_PAYLOAD_SIZE 200  // Audio payload size

// --- Globals ---
const uint64_t Local_MAC = ESP.getEfuseMac();
volatile bool Radio_Operation_Flag = false; // ISR Flag
volatile bool Boot_Key_Flag = false;        // Button Flag
bool Transmission_Mode = false;             // false = RX (Listen), true = TX (Talk)

// Audio Streams (Dynamic Buffers)
std::vector<int16_t> IIS_Read_Stream;       // Mic -> Encoder
std::vector<int16_t> IIS_Write_Stream;      // Decoder -> Speaker
std::vector<uint8_t> Radio_Tx_Stream;       // Encoder -> Radio
std::vector<uint8_t> Radio_Rx_Stream;       // Radio -> Decoder

// Packet Buffers
uint8_t Send_Package[PACKET_HEADER_SIZE + PACKET_PAYLOAD_SIZE];
uint8_t Receive_Package[PACKET_HEADER_SIZE + PACKET_PAYLOAD_SIZE];

// --- Hardware Objects ---
#if defined T3_S3_MVSRBoard_V1_0
std::shared_ptr<Arduino_IIS_DriveBus> IIS_Bus_In =
    std::make_shared<Arduino_HWIIS>(I2S_NUM_0, MSM261_BCLK, MSM261_WS, MSM261_DATA);
#elif defined T3_S3_MVSRBoard_V1_1
std::shared_ptr<Arduino_IIS_DriveBus> IIS_Bus_In =
    std::make_shared<Arduino_HWIIS>(I2S_NUM_0, -1, MP34DT05TR_LRCLK, MP34DT05TR_DATA);
#else
#error "Please select the correct board definition."
#endif

std::unique_ptr<Arduino_IIS> IIS_Mic(new Arduino_MEMS(IIS_Bus_In));

std::shared_ptr<Arduino_IIS_DriveBus> IIS_Bus_Out =
    std::make_shared<Arduino_HWIIS>(I2S_NUM_1, MAX98357A_BCLK, MAX98357A_LRCLK, MAX98357A_DATA);

std::unique_ptr<Arduino_IIS> IIS_Speaker(new Arduino_Amplifier(IIS_Bus_Out));

SX1262 radio = new Module(LORA_CS, LORA_DIO1, LORA_RST, LORA_BUSY, SPI);

// --- Helper: Prepare Header ---
void prepare_header() {
    Send_Package[0] = 'M'; Send_Package[1] = 'A'; Send_Package[2] = 'C'; Send_Package[3] = ':';
    for (int i = 0; i < 8; i++) {
        Send_Package[4 + i] = (uint8_t)(Local_MAC >> (56 - (i * 8)));
    }
}

// --- ISRs ---
void IRAM_ATTR Radio_Interrupt(void) {
    Radio_Operation_Flag = true;
}

void IRAM_ATTR Button_Interrupt(void) {
    Boot_Key_Flag = true;
}

// --- Task: Codec2 (Audio Engine) ---
void Codec2_Task(void *parameter) {
    struct CODEC2 *c2 = codec2_create(CODEC2_MODE_3200);
    if (!c2) { Serial.println("Codec2 Init Failed"); vTaskDelete(NULL); }
    
    // Post-filter makes the voice sound less "robotic"
    codec2_set_lpc_post_filter(c2, 1, 0, 0.8, 0.2);

    const int n_samp = codec2_samples_per_frame(c2); // Samples per frame (160 for 3200 mode)
    const int n_bytes = codec2_bytes_per_frame(c2);  // Bytes per compressed frame (40)

    int16_t *sample_buf = (int16_t*)malloc(sizeof(int16_t) * n_samp);
    int16_t *decode_buf = (int16_t*)malloc(sizeof(int16_t) * n_samp);
    uint8_t *code_buf   = (uint8_t*)malloc(n_bytes);

    // How many frames fit in one radio packet? (200 bytes / 40 bytes = 5 frames)
    const int frames_per_packet = PACKET_PAYLOAD_SIZE / n_bytes; 

    Serial.printf("Audio Engine Started: %d samples/frame, %d bytes/frame\n", n_samp, n_bytes);

    while (1) {
        // --- TX: Microphone -> Codec2 -> Radio Stream ---
        if (Transmission_Mode) {
            // We need 5 frames to fill a packet
            for (int f = 0; f < frames_per_packet; f++) {
                // Read Mono Audio
                if (IIS_Mic->IIS_Read_Data(sample_buf, n_samp * sizeof(int16_t))) {
                    // Encode
                    codec2_encode(c2, code_buf, sample_buf);
                    
                    // Push to Radio Stream
                    size_t curr_size = Radio_Tx_Stream.size();
                    Radio_Tx_Stream.resize(curr_size + n_bytes);
                    memcpy(Radio_Tx_Stream.data() + curr_size, code_buf, n_bytes);
                }
            }
        }

        // --- RX: Radio Stream -> Codec2 -> Speaker Stream ---
        if (Radio_Rx_Stream.size() >= n_bytes) {
            // Pop one frame from stream
            memcpy(code_buf, Radio_Rx_Stream.data(), n_bytes);
            Radio_Rx_Stream.erase(Radio_Rx_Stream.begin(), Radio_Rx_Stream.begin() + n_bytes);

            // Decode
            codec2_decode(c2, decode_buf, code_buf);

            // Convert Mono -> Stereo (Duplicate channels) & Gain
            std::vector<int16_t> stereo_out;
            stereo_out.reserve(n_samp * 2);
            for (int i = 0; i < n_samp; i++) {
                int16_t val = decode_buf[i] * 5; // Gain x5
                stereo_out.push_back(val);
                stereo_out.push_back(val);
            }

            // Push to Speaker Stream
            size_t curr_size = IIS_Write_Stream.size();
            IIS_Write_Stream.resize(curr_size + stereo_out.size());
            memcpy(IIS_Write_Stream.data() + curr_size, stereo_out.data(), stereo_out.size() * sizeof(int16_t));
        }

        vTaskDelay(1); // Yield
    }
}

// --- Task: Speaker Playback ---
void MAX_Play_Task(void *parameter) {
    const size_t chunk_size = 320 * sizeof(int16_t); // Play in small chunks
    int16_t play_buf[320];

    while (1) {
        if (IIS_Write_Stream.size() >= 320) {
            // Copy from stream
            memcpy(play_buf, IIS_Write_Stream.data(), chunk_size);
            
            // Remove from stream
            IIS_Write_Stream.erase(IIS_Write_Stream.begin(), IIS_Write_Stream.begin() + 320);

            // Write to I2S Hardware
            IIS_Speaker->IIS_Write_Data(play_buf, chunk_size);
        } else {
            vTaskDelay(2); // Wait for data
        }
    }
}

// --- Main Setup ---
void setup() {
    Serial.begin(115200);
    prepare_header();

    // Button
    pinMode(0, INPUT_PULLUP);
    attachInterrupt(BOOT_KEY, Button_Interrupt, FALLING);

    // Amp Enable
    pinMode(MAX98357A_SD_MODE, OUTPUT);
    digitalWrite(MAX98357A_SD_MODE, HIGH);

    // Mic Init
    #if defined T3_S3_MVSRBoard_V1_0
        pinMode(MSM261_EN, OUTPUT); digitalWrite(MSM261_EN, HIGH);
        IIS_Mic->begin(i2s_mode_t::I2S_MODE_MASTER, ad_iis_data_mode_t::AD_IIS_DATA_IN, i2s_channel_fmt_t::I2S_CHANNEL_FMT_ONLY_RIGHT, IIS_DATA_BIT, IIS_SAMPLE_RATE);
    #elif defined T3_S3_MVSRBoard_V1_1
        pinMode(MP34DT05TR_EN, OUTPUT); digitalWrite(MP34DT05TR_EN, LOW);
        IIS_Mic->begin(i2s_mode_t::I2S_MODE_PDM, ad_iis_data_mode_t::AD_IIS_DATA_IN, i2s_channel_fmt_t::I2S_CHANNEL_FMT_ONLY_RIGHT, IIS_DATA_BIT, IIS_SAMPLE_RATE);
    #endif

    // Speaker Init
    IIS_Speaker->begin(i2s_mode_t::I2S_MODE_MASTER, ad_iis_data_mode_t::AD_IIS_DATA_OUT, i2s_channel_fmt_t::I2S_CHANNEL_FMT_RIGHT_LEFT, IIS_DATA_BIT, IIS_SAMPLE_RATE);

    // --- Radio Init (The Critical Part) ---
    Serial.print("[SX1262] Initializing FSK ... ");
    SPI.begin(LORA_SCLK, LORA_MISO, LORA_MOSI);
    
    // Start FSK: Freq, BitRate, FreqDev, RxBw, Power, Preamble, TCXO
    int state = radio.beginFSK(FSK_FREQ, FSK_BITRATE, FSK_FREQ_DEV, FSK_RX_BW, FSK_PWR, FSK_PREAMBLE, 1.6);
    
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println("Success!");
    } else {
        Serial.printf("Failed, code %d\n", state);
        while (true);
    }

    // FSK Fine Tuning
    uint8_t syncWord[] = {0x2D, 0xD4}; 
    radio.setSyncWord(syncWord, 2);
    radio.setCRC(2);            // 2-byte CRC to filter bad audio packets
    radio.setWhitening(true);   // Whitening for DC balance
    radio.setPacketMode(RADIOLIB_SX126X_GFSK_PACKET_VARIABLE);
    radio.setDio1Action(Radio_Interrupt);
    
    // Create Tasks
    xTaskCreatePinnedToCore(Codec2_Task, "AudioEngine", 32000, NULL, 5, NULL, 1); // Core 1
    xTaskCreatePinnedToCore(MAX_Play_Task, "Player", 10000, NULL, 5, NULL, 1);    // Core 1

    // Start Listening
    radio.startReceive();
}

// --- Main Loop ---
void loop() {
    
    // 1. Handle Button (Mode Toggle)
    if (Boot_Key_Flag) {
        delay(200); // Debounce
        Boot_Key_Flag = false;

        Transmission_Mode = !Transmission_Mode;
        
        // Clear buffers on switch to avoid playing old audio
        IIS_Read_Stream.clear();
        IIS_Write_Stream.clear();
        Radio_Tx_Stream.clear();
        Radio_Rx_Stream.clear();

        if (Transmission_Mode) {
            Serial.println(">>> TALK MODE <<<");
        } else {
            Serial.println("<<< LISTEN MODE >>>");
            radio.startReceive();
        }
    }

    // 2. Handle Transmission (If in Talk Mode)
    // If we have enough compressed data for a full packet, send it.
    if (Transmission_Mode && Radio_Tx_Stream.size() >= PACKET_PAYLOAD_SIZE) {
        
        // Prepare Payload
        memcpy(&Send_Package[PACKET_HEADER_SIZE], Radio_Tx_Stream.data(), PACKET_PAYLOAD_SIZE);
        
        // Remove from Stream
        Radio_Tx_Stream.erase(Radio_Tx_Stream.begin(), Radio_Tx_Stream.begin() + PACKET_PAYLOAD_SIZE);

        // Transmit (Blocking is okay here because FSK is fast)
        radio.transmit(Send_Package, PACKET_HEADER_SIZE + PACKET_PAYLOAD_SIZE);
        
        // Note: RadioLib usually puts radio in Standby after TX.
        // We don't need to startReceive() here because we are the talker.
    }

    // 3. Handle Interrupts (RX or TX Done)
    if (Radio_Operation_Flag) {
        Radio_Operation_Flag = false;

        uint16_t flags = radio.getIRQFlags();

        // Check for Valid Packet Reception
        if ((flags & RADIOLIB_SX126X_IRQ_RX_DONE) && !(flags & RADIOLIB_SX126X_IRQ_CRC_ERR)) {
            
            int state = radio.readData(Receive_Package, PACKET_HEADER_SIZE + PACKET_PAYLOAD_SIZE);

            if (state == RADIOLIB_ERR_NONE) {
                // Verify Header (Magic Bytes)
                if (Receive_Package[0] == 'M' && Receive_Package[1] == 'A' && Receive_Package[2] == 'C') {
                    
                    // Optional: Check MAC to ignore self (if needed)
                    // ...

                    // Push Payload to RX Stream for Decoding
                    size_t curr_size = Radio_Rx_Stream.size();
                    Radio_Rx_Stream.resize(curr_size + PACKET_PAYLOAD_SIZE);
                    memcpy(Radio_Rx_Stream.data() + curr_size, &Receive_Package[PACKET_HEADER_SIZE], PACKET_PAYLOAD_SIZE);
                    
                    Serial.printf("RX: %d dBm\n", (int)radio.getRSSI());
                }
            }
        }

        // Always resume listening if we are not the talker
        if (!Transmission_Mode) {
            radio.startReceive();
        }
    }

    vTaskDelay(2); // Keep watchdog happy
}
